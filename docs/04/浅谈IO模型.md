# 浅谈IO模型

## 一、五种IO模型
在《Unix网络编程》一书中提到了五种IO模型，分别是：阻塞IO、非阻塞IO、多路复用IO、信号驱动IO以及异步IO。
- 阻塞IO:
    进程调用读取指令后阻塞直至数据复制到内存完毕 一个进程或线程对应一个连接
- 非阻塞IO:
    进程调用读取指令后进程可以处理其他任务后再查看是否数据准备完毕 准备完毕后阻塞至数据从IO设备复制至内存中
- 多路复用IO:
    改进的阻塞IO 可以处理多个连接
- 信号驱动IO:
    进程调用读取指令后内核在IO设备数据准备完毕后通过回调函数使进程阻塞至数据从IO设备复制到内存完毕
- 异步IO:
    进程调用读取指令后内核负责处理数据从IO设备直至复制至内存后再回调进程函数

IO多路复用, 用故事来描述如下：

是找一个宿管大妈来帮你监视下楼的女生, 这个期间你可以些其他的事情. 例如可以顺便看看其他妹子,玩玩王者荣耀, 上个厕所等等. 

IO复用又包括 select, poll, epoll 模式. 那么它们的区别是什么?
- 1、select大妈 每一个女生下楼, select大妈都不知道这个是不是你的女神, 她需要一个一个询问, 并且select大妈能力还有限, 最多一次帮你监视1024个妹子
- 2、poll大妈不限制盯着女生的数量, 只要是经过宿舍楼门口的女生, 都会帮你去问是不是你女神
- 3、epoll大妈不限制盯着女生的数量, 并且也不需要一个一个去问. 那么如何做呢? epoll大妈会为每个进宿舍楼的女生脸上贴上一个大字条,上面写上女生自己的名字, 只要女生下楼了, epoll大妈就知道这个是不是你女神了, 然后大妈再通知你.

备注:
select和poll和epoll具体实现方式参考：https://www.jianshu.com/p/6a6845464770

## 二、两种网络服务设计模式
传统网络设计过程中，有两种比较经典的模式，一种是多线程，一种是线程池

多线程就是，来了client，服务器就会新建一个线程来处理该client的读写事件，从下图，我们可以看到

![io](../images/04/io_1.jpg)

但是多线程存在一个问题：由于服务器为每个client的连接都采用一个线程去处理，使得资源占用非常大。因此，当连接数量达到上限时，再有用户请求连接，直接会导致资源瓶颈，严重的可能会直接导致服务器崩溃。

**多线程存在的问题的解决办法**: 

创建一个固定大小的线程池，来一个客户端，就从线程池取一个空闲线程来处理，当客户端处理完读写操作之后，就交出对线程的占用。因此这样就避免为每一个客户端都要创建线程带来的资源浪费，使得线程可以重用。

**线程池的弊端**:

如果连接大多是长连接，因此可能会导致在一段时间内，线程池中的线程都被占用，那么当再有用户请求连接时，由于没有可用的空闲线程来处理，就会导致客户端连接失败，从而影响用户体验。因此，线程池比较适合大量的短连接应用。

因此便出现了下面的两种高性能IO设计模式：Reactor和Proactor

## 三、两种高性能IO设计模式
> Reactor和Proactor

### Reactor模式：
在Reactor模式中，会先对每个client注册感兴趣的事件，然后有一个线程专门去轮询每个client是否有事件发生，当有事件发生时，便顺序处理每个事件，当所有事件处理完之后，便再转去继续轮询，如下图所示

![io](../images/04/io2.jpg)

上面的五种IO模型中的多路复用IO就是采用Reactor模式,Java NIO使用的就是这种

注：图中事件是串行调用的，我们为了提高效率，也可以采用线程池或者多线程来实现

### Proactor模式：
当检测到有事件发生时，会新起一个异步操作，然后交由内核线程去处理，当内核线程完成IO操作之后，发送一个通知告知操作已完成，可以得知，异步IO模型采用的就是Proactor模式，Java AIO使用的这种

参考资料：
- https://www.jianshu.com/p/6a6845464770
- https://blog.csdn.net/ocean_fan/article/details/79622956
- https://www.jianshu.com/p/cff711421d0e

